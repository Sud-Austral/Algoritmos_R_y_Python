---
title: "Carga de la evoluci√≥n del r0 de un conjunto de entidades en un csv"
author: "DataIntelligence"
date: "22-06-2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE
)
```

```{r uno}

library(janitor)
library(dplyr)
library(readxl)

# la siguiente linea impide el despliegue de advertencias en forma local:
options(warn = -1)

library(tidyverse)
library(gghighlight)
library(magrittr)
library(readr)
library(ape)
library(ggdendro)
library(rmarkdown)
library(ggplot2)
library(gganimate)
theme_set(theme_bw()) 

```
```{r dos}
covid19 <- read_xlsx("distritos_con_cod.xlsx")

# corregimos el formato del dato fecha del excel:
covid19$Fecha <- excel_numeric_to_date(covid19$Fecha)

# se declara un vector que almacene los valores de R0:
a <- c()
```

```{r tres}     

for(t in 1:81)
{
        # construimos una subtabla que contenga solo las filas determinadas por un codigo fijo:
        comuna_en_cuestion = covid19[covid19$codigo == t,]
        
        longitud = nrow(comuna_en_cuestion)
        comu <- comuna_en_cuestion$Comuna 
        
        if(nrow(comuna_en_cuestion) != 0 && comuna_en_cuestion$Poblacion != 0)
        {          
                
                # unique() devuelve un vector, un dataframe o una matriz como x,
                # pero con sus elementos (o filas) duplicados eliminados.
                # population = as.numeric(comuna_en_cuestion$Poblacion) %>% unique()
                
                # Si la tabla excel contiene el dato de la poblacion constante
                # para todas las fechas no es necesario:
                population = as.numeric(comuna_en_cuestion$Poblacion)
                
                # Construimos una subtabla con dos columnas: 
                # los datos de los casos diarios y la fecha:
                
                # Notemos algo en este trozo de codigo: FUN = sum no hace nada porque 
                # no se puede agrupar construyendo una suma ya que cada fecha es unica. Es importante
                # porque nos permite construir la subtabla que necesitamos:
                
                # La tabla se crea con los datos de las columnas invertidos: primero la fecha, luego los                  # casos diarios:
                infectados.por.dia = aggregate(comuna_en_cuestion$Casos_Diarios ~ comuna_en_cuestion$Fecha, FUN = sum)

                fallecidos.por.dia = aggregate(comuna_en_cuestion$Fallecidos_Diarios ~ comuna_en_cuestion$Fecha, FUN = sum)
                
                # sumamos a los infectados diarios los casos diarios y los fallecidos, ya que el modelo                   # SIR no considera a los fallecidos.
                infectados.por.dia2 =infectados.por.dia[,2] + fallecidos.por.dia[,2]
                
                recuperados.por.dia = aggregate(comuna_en_cuestion$Recuperados_Diarios ~
                                                        comuna_en_cuestion$Fecha, FUN = sum)
                
                # Los susceptibles por dia no es un valor agregado. En todas las filas a la constante de                  # poblacion se le restan los valores de infectados del dia y los recuperados del dia:
                susceptibles.por.dia = population - infectados.por.dia2 - recuperados.por.dia[,2]
                
                # Creamos la tabla SIR:
                tabla.comuna = data.frame(unique(comuna_en_cuestion$Fecha), susceptibles.por.dia, infectados.por.dia2,recuperados.por.dia[,2])
                
                names(tabla.comuna) = c("Fecha", "Susceptibles", "Infectados", "Recuperados")
                
                # Obtenemos los valores que vamos a necesitar para correr nuestras regresiones lineales                   # para obtener R0:
                x = tabla.comuna$Recuperados
                y = population*log(tabla.comuna$Susceptibles)
        }
        
        # Verifiquemos los valores obtenidos:
        print(tabla.comuna)
        print(x)
        print(y)
        
        # En esta seccion vamos almacenando en el vector a los valores de r0 en intervalos
        # desde el primer dia (puede ser desde el segundo, da lo mismo) hasta el segundo dia, 
        # desde el primero hasta el tercero, desde el primero hasta el cuarto y asi sucesivamente.
        
        # Declaramos una secuancia con los valores del estremo superior de estos intervalos:
        m <- seq(2, longitud)
        
        for (i in m) 
        {
                xx <- x[1:i]
                yy <- y[1:i]
                estimacion.R0 = -summary(lm(yy ~ xx))$coefficients[2]
                a[i] <- estimacion.R0
        }

        x <-  1:longitud
        
        eee <- data.frame(comu, x, a)
        
        # Verifiquemos lo que vamos a guardar en el csv:
        print(eee)

        write.table(eee,'opepanama.csv', col.names=F, append=T, sep = ",")

}

```
