---
title: "R0 en el tiempo en rangos y con dos valores."
author: "DataIntelligence"
date: "05-09-2020"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE
)
```

Aplicaremos el calculo del R0 no a los rangos de series de tiempo sino a dos momentos, a dos dias. Demostraremos que el resultado es idéntico al de si hiciéramos el cálculo sobre rangos de tiempo.



```{r uno}
library(knitr)
library(kableExtra)
library(janitor)
library(dplyr)
library(readxl)
library(xlsx)
# la siguiente linea impide el despliegue de advertencias en forma local:
options(warn = -1)
library(tidyverse)
library(gghighlight)
library(magrittr)
library(readr)
library(ape)
library(ggdendro)
library(rmarkdown)
library(ggplot2)
library(gganimate)
library(lubridate)
library(plotly)

theme_set(theme_bw()) 
```


```{r cinco}


 covid19 <-
  read_xlsx("C:/Users/usuario/Desktop/GitHub-trabajo/Algoritmos_R_y_Python/R0/R0_R/salida.xlsx")

head(covid19)
covid19 <-  covid19 %>% filter(Comuna == 'Punta Arenas') 

covid19 <- subset(covid19, Comuna != "Chillán")

covid19 <- subset(covid19, Fecha> "2020-05-22")


#covid19 <- subset(covid19, Fecha > "43934")
# covid19 <- covid19[5,]


# covid19

R0_v <- c()
comuna_v <- c()
codigo_comuna_v <- c()
a2 <- 0
s2 <- 0
s_v2 <- c()
y_bueno2 <- c()

R0_v2 <- c()
comuna_v2 <- c()
codigo_comuna_v2 <- c()
a <- 0
s <- 0
s_v <- c()
y_bueno <- c()

Fecha <- as.Date(covid19$Fecha, origin = "1899-12-30")

```


```{r tres}  

ux <- unique(covid19$"Codigo comuna")

for(t in ux)
{
    # susceptibles.por.dia2 <- 0
    
    
    if (t != "No Informado")
    {
        comuna_en_cuestion = covid19[covid19$"Codigo comuna" == t, ]
        
        longitud = nrow(comuna_en_cuestion)
        
        comuna <- comuna_en_cuestion$Comuna
        codigo_comuna <- comuna_en_cuestion$"Codigo comuna"
        # dia <- comuna_en_cuestion$"Día"
        fecha <- comuna_en_cuestion$Fecha
        
        
        if (nrow(comuna_en_cuestion) != 0 && (comuna_en_cuestion$"Poblacion" != 0))
        {
            population = as.numeric(comuna_en_cuestion$"Poblacion")
            
            infectados.por.dia <<- cumsum(as.numeric(comuna_en_cuestion$"Nuevos"))

            fallecidos.por.dia <<- cumsum(as.numeric(comuna_en_cuestion$"Nuevos Fallecidos"))

            infectados.por.dia2 = as.numeric(infectados.por.dia + fallecidos.por.dia)
            
            recuperados.por.dia = cumsum(as.numeric(comuna_en_cuestion$"Nuevos Recuperados"))
            
            # susceptibles.por.dia debe ir acumulando
            
            susceptibles.por.dia = population - infectados.por.dia2 - recuperados.por.dia
            
            
            # Creamos la tabla SIR:
            tabla.comuna =
                data.frame(
                    unique(comuna_en_cuestion$Fecha),
                    susceptibles.por.dia,
                    infectados.por.dia2,
              #      infec.acum,
                    recuperados.por.dia,
                    population
                )
            
            names(tabla.comuna) =
                c("Fecha",
                  "Susceptibles",
                  "Infectados",
              #    "Infectados acumulados",
                  "Recuperados",
                  "Poblacion")
            
            x = tabla.comuna$Recuperados
            
            # se generan singularidades 
            y = population * log(tabla.comuna$Susceptibles)
        }
    }
print(tabla.comuna)

    # # susceptibles.por.dia debe ir acumulando la resta de infectados
    # for (t in 1:nrow(comuna_en_cuestion))
    # {
    #     s <<- s + tabla.comuna$Infectados[t] + tabla.comuna$Recuperados[t]
    #     s_v[t] <- tabla.comuna$Poblacion - s
    #     y_bueno[t] = population * log(s_v[t])
    # }
    # 
    # dataf = data.frame(s_v, tabla.comuna$Infectados,  y_bueno, tabla.comuna$Recuperados)
    # print(dataf)

    m <- seq(2, longitud)
    
    for (i in m)
    {        
        xx <- tabla.comuna$Recuperados[1:i]
        # xx <- tabla.comuna$Recuperados[i-1:i]

        yy <- y[1:i]
        # yy <- y[i-1:i]
        
        if(!is.null(yy)){
        estimacion.R0 = -summary(lm(yy ~ xx))$coefficients[2]
        R0_v[i] <- estimacion.R0
        comuna_v <- comuna
        codigo_comuna_v <- codigo_comuna
        fecha_v <- fecha
        # dia_v <- dia
        }
    }
    
    for (i in m)
    {        
        #xx <- tabla.comuna$Recuperados[1:i]
        xxx <- tabla.comuna$Recuperados[i-1:i]

        #yy <- y[1:i]
        yyy <- y[i-1:i]
        
        if(!is.null(yyy)){
        estimacion.R02 = -summary(lm(yyy ~ xxx))$coefficients[2]
        R0_v2[i] <- estimacion.R02
        comuna_v2 <- comuna
        codigo_comuna_v2 <- codigo_comuna
        fecha_v2 <- fecha
        # dia_v <- dia
        }
    }

    
    
    
    
    
    eee <- data.frame(comuna_v, R0_v , fecha_v)

    write.table(
        eee,
        'R0.csv',
        col.names = F,
        append = T,
        sep = ","
    )
    
    
    eee2 <- data.frame(comuna_v2, R0_v2 , fecha_v)

    write.table(
        eee2,
        'R02.csv',
        col.names = F,
        append = T,
        sep = ","
    )
    
    
    R0_v <- c()
    comuna_v <- c()
    codigo_comuna_v <-  c()
    a <- 0
    s <- 0
    s_v <- c()
    y <- c()
    
    R0_v2 <- c()
    comuna_v2 <- c()
    codigo_comuna_v2 <-  c()
    a2 <- 0
    s2 <- 0
    s_v2 <- c()
    y2 <- c()
}
head(eee, 50)
head(eee2, 50)
```
Y y X de la regresion lineal

```{r}

p <- ggplot(eee, aes(x=fecha_v, y=R0_v)) + geom_point(aes(y = R0_v), colour = "red")  

o <- ggplot(eee2, aes(x=fecha_v, y=R0_v2)) + geom_point(aes(y = R0_v2), colour = "blue") 
o

#income.graph <- income.graph + geom_smooth(method="loess", col="red", size = 0.5)
# income.graph



```







